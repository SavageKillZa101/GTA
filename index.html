<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web GTA - Enhanced Edition</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            overflow: hidden; 
            font-family: 'Courier New', monospace;
            background: #000;
        }
        canvas { display: block; }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #0f0;
            z-index: 100;
            font-size: 14px;
            min-width: 300px;
            backdrop-filter: blur(5px);
        }
        
        #hud h1 {
            color: #ffcc00;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ffcc00;
        }
        
        #hud div {
            margin: 5px 0;
        }
        
        #hud .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 5px;
            border: 1px solid #0f0;
        }
        
        #weapon-wheel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.8) 70%, transparent 100%);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            border: 3px solid #ffcc00;
            box-shadow: 0 0 50px rgba(255, 204, 0, 0.5);
        }
        
        .weapon-slot {
            position: absolute;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            padding: 20px;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transform-origin: center;
        }
        
        .weapon-slot:hover {
            background: #ffcc00;
            color: #000;
            transform: scale(1.2);
            border-color: #ffcc00;
            box-shadow: 0 0 20px #ffcc00;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 50;
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        #crosshair::before {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }
        
        #crosshair::after {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }
        
        #ammo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            display: none;
        }
        
        .debug {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: #ffcc00;
        }
        
        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>GTA WEB ENGINE</h1>
        <p>Loading game assets...</p>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>
    
    <div id="crosshair"></div>
    <div id="ammo"></div>
    <div id="hud">
        <h1>GTA WEB ENGINE v2.0</h1>
        <div><span class="key">WASD</span> Move Character</div>
        <div><span class="key">Mouse</span> Look Around</div>
        <div><span class="key">Left Click</span> Fire Weapon</div>
        <div><span class="key">Tab</span> Weapon Wheel</div>
        <div><span class="key">F</span> Enter/Exit Vehicle</div>
        <div><span class="key">Space</span> Jump</div>
        <div><span class="key">Shift</span> Sprint</div>
        <div><span class="key">R</span> Reload</div>
        <div id="current-weapon">Weapon: FISTS</div>
        <div id="vehicle-status">Vehicle: Not in vehicle</div>
    </div>
    
    <div id="weapon-wheel">
        <div class="weapon-slot" style="top: 10%; left: 50%; transform: translateX(-50%);" onclick="equip('fist')">üëä</div>
        <div class="weapon-slot" style="top: 50%; right: 10%; transform: translateY(-50%);" onclick="equip('pistol')">üî´</div>
        <div class="weapon-slot" style="bottom: 10%; left: 50%; transform: translateX(-50%);" onclick="equip('shotgun')">üí•</div>
        <div class="weapon-slot" style="top: 50%; left: 10%; transform: translateY(-50%);" onclick="equip('m4')">üî´</div>
        <div class="weapon-slot" style="top: 25%; left: 25%;" onclick="equip('katana')">üó°Ô∏è</div>
        <div class="weapon-slot" style="top: 25%; right: 25%;" onclick="equip('rpg')">üöÄ</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';

    // --- GAME STATE ---
    const gameState = {
        currentWeapon: 'fist',
        weapons: {
            fist: { name: 'Fists', ammo: '‚àû', damage: 10, range: 2 },
            pistol: { name: 'Pistol', ammo: 12, maxAmmo: 12, damage: 25, range: 100 },
            shotgun: { name: 'Shotgun', ammo: 6, maxAmmo: 6, damage: 50, range: 30 },
            m4: { name: 'M4 Rifle', ammo: 30, maxAmmo: 30, damage: 35, range: 200 },
            katana: { name: 'Katana', ammo: '‚àû', damage: 40, range: 3 },
            rpg: { name: 'RPG', ammo: 1, maxAmmo: 1, damage: 100, range: 500 }
        },
        isDriving: false,
        playerHealth: 100,
        playerMoney: 500,
        wantedLevel: 0
    };

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x87CEEB, 100, 2000);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 10, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- LIGHTING ---
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(100, 200, 100);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.far = 1000;
    scene.add(directionalLight);

    // --- LOADING MANAGER ---
    const loadingManager = new THREE.LoadingManager();
    const loader = new GLTFLoader(loadingManager);
    
    let totalAssets = 6;
    let loadedAssets = 0;
    
    loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
        loadedAssets = itemsLoaded;
        const progress = (itemsLoaded / itemsTotal) * 100;
        document.getElementById('progress-fill').style.width = `${progress}%`;
    };
    
    loadingManager.onLoad = () => {
        setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('crosshair').style.display = 'block';
        }, 500);
    };

    // --- GAME OBJECTS ---
    let player = null;
    let playerMixer = null;
    let playerAnimations = {};
    let handBone = null;
    let truck = null;
    let weaponModels = {};
    let currentWeaponObject = null;
    
    // Fallback player model if custom model fails
    function createFallbackPlayer() {
        const group = new THREE.Group();
        
        // Body
        const bodyGeometry = new THREE.BoxGeometry(1, 2, 0.5);
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        group.add(body);
        
        // Head
        const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffcc99 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 1.2;
        head.castShadow = true;
        group.add(head);
        
        // Arms
        const armGeometry = new THREE.BoxGeometry(0.2, 1, 0.2);
        const armMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        
        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(0.6, 0.5, 0);
        leftArm.castShadow = true;
        group.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(-0.6, 0.5, 0);
        rightArm.castShadow = true;
        group.add(rightArm);
        
        // Create a dummy bone for weapon attachment
        const bone = new THREE.Bone();
        bone.position.set(-0.6, 0.5, 0);
        group.add(bone);
        handBone = bone;
        
        player = group;
        player.scale.set(5, 5, 5);
        player.position.set(0, 0, 0);
        scene.add(player);
        
        console.log("Using fallback player model");
    }

    // --- LOAD ASSETS ---
    
    // Load city
    loader.load('https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf', (gltf) => {
        const city = gltf.scene;
        city.scale.set(100, 100, 100);
        city.position.set(0, -10, 0);
        city.traverse((node) => {
            if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        scene.add(city);
    }, undefined, (error) => {
        console.error("Failed to load city, creating simple ground:", error);
        createGround();
    });

    // Create simple ground if city fails to load
    function createGround() {
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x3a7c3a,
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -10;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Add some buildings
        for (let i = 0; i < 50; i++) {
            const size = Math.random() * 20 + 10;
            const buildingGeometry = new THREE.BoxGeometry(size, size * 3, size);
            const buildingMaterial = new THREE.MeshPhongMaterial({ 
                color: Math.random() * 0xffffff 
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(
                Math.random() * 800 - 400,
                size * 1.5 - 10,
                Math.random() * 800 - 400
            );
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
        }
    }

    // Load player
    loader.load('https://threejs.org/examples/models/gltf/Flamingo/Flamingo.gltf', (gltf) => {
        player = gltf.scene;
        player.scale.set(0.05, 0.05, 0.05);
        player.position.set(0, 0, 0);
        
        // Find hand bone
        player.traverse((node) => {
            if (node.isBone) {
                if (node.name.toLowerCase().includes('hand') || 
                    node.name.includes('wrist') || 
                    node.name.includes('arm')) {
                    handBone = node;
                    console.log("Found hand bone:", node.name);
                }
            }
        });
        
        if (!handBone) {
            // Create a dummy bone at hand position
            handBone = new THREE.Bone();
            handBone.position.set(0, 1, 0);
            player.add(handBone);
        }
        
        player.traverse((node) => {
            if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        
        scene.add(player);
        
        // Animation mixer
        if (gltf.animations.length > 0) {
            playerMixer = new THREE.AnimationMixer(player);
            gltf.animations.forEach((clip, i) => {
                playerAnimations[clip.name] = clip;
                if (i === 0) playerMixer.clipAction(clip).play();
            });
        }
        
    }, undefined, (error) => {
        console.error("Failed to load player model, using fallback:", error);
        createFallbackPlayer();
    });

    // Load truck
    loader.load('https://threejs.org/examples/models/gltf/LeePerrySmith/LeePerrySmith.glb', (gltf) => {
        truck = gltf.scene;
        truck.scale.set(5, 5, 5);
        truck.position.set(50, 0, 50);
        truck.traverse((node) => {
            if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        
        // Add collision box
        const box = new THREE.Box3().setFromObject(truck);
        truck.userData.boundingBox = box;
        
        scene.add(truck);
        
    }, undefined, (error) => {
        console.error("Failed to load truck, creating simple vehicle:", error);
        createSimpleVehicle();
    });

    // Create simple vehicle if model fails
    function createSimpleVehicle() {
        const group = new THREE.Group();
        
        // Car body
        const bodyGeometry = new THREE.BoxGeometry(4, 1, 8);
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        group.add(body);
        
        // Windows
        const windowGeometry = new THREE.BoxGeometry(3.5, 0.8, 1.5);
        const windowMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x88ccff,
            transparent: true,
            opacity: 0.5
        });
        const window = new THREE.Mesh(windowGeometry, windowMaterial);
        window.position.set(0, 0.9, 0.5);
        group.add(window);
        
        // Wheels
        const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        
        for (let i = 0; i < 4; i++) {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            const x = i % 2 === 0 ? -1.8 : 1.8;
            const z = i < 2 ? -2.5 : 2.5;
            wheel.position.set(x, -0.5, z);
            wheel.rotation.z = Math.PI / 2;
            wheel.castShadow = true;
            group.add(wheel);
        }
        
        truck = group;
        truck.scale.set(2, 2, 2);
        truck.position.set(50, 0, 50);
        
        // Add collision box
        const box = new THREE.Box3().setFromObject(truck);
        truck.userData.boundingBox = box;
        
        scene.add(truck);
    }

    // Create weapon models
    function createWeaponModels() {
        // Create simple weapon geometries
        const weapons = {
            pistol: createPistol(),
            shotgun: createShotgun(),
            m4: createM4(),
            katana: createKatana(),
            rpg: createRPG()
        };
        
        weaponModels = weapons;
    }

    function createPistol() {
        const group = new THREE.Group();
        
        const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.2, 0.05),
            new THREE.MeshPhongMaterial({ color: 0x444444 })
        );
        
        const barrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.3, 8),
            new THREE.MeshPhongMaterial({ color: 0x222222 })
        );
        barrel.position.y = 0.1;
        barrel.rotation.z = Math.PI / 2;
        
        group.add(handle, barrel);
        group.scale.set(20, 20, 20);
        
        return group;
    }

    function createShotgun() {
        const group = new THREE.Group();
        
        const stock = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.3, 0.05),
            new THREE.MeshPhongMaterial({ color: 0x8B4513 })
        );
        
        const barrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8),
            new THREE.MeshPhongMaterial({ color: 0x222222 })
        );
        barrel.position.y = 0.15;
        barrel.rotation.z = Math.PI / 2;
        
        group.add(stock, barrel);
        group.scale.set(15, 15, 15);
        
        return group;
    }

    function createM4() {
        const group = new THREE.Group();
        
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.4, 0.05),
            new THREE.MeshPhongMaterial({ color: 0x666666 })
        );
        
        const barrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.6, 8),
            new THREE.MeshPhongMaterial({ color: 0x222222 })
        );
        barrel.position.y = 0.2;
        barrel.rotation.z = Math.PI / 2;
        
        const scope = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.05, 0.1),
            new THREE.MeshPhongMaterial({ color: 0x000000 })
        );
        scope.position.set(0, 0.25, 0);
        
        group.add(body, barrel, scope);
        group.scale.set(15, 15, 15);
        
        return group;
    }

    function createKatana() {
        const group = new THREE.Group();
        
        const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, 0.2, 8),
            new THREE.MeshPhongMaterial({ color: 0x8B4513 })
        );
        
        const blade = new THREE.Mesh(
            new THREE.BoxGeometry(0.01, 0.8, 0.02),
            new THREE.MeshPhongMaterial({ color: 0xcccccc })
        );
        blade.position.y = 0.5;
        
        const guard = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.02, 0.02),
            new THREE.MeshPhongMaterial({ color: 0x888888 })
        );
        guard.position.y = 0.1;
        
        group.add(handle, blade, guard);
        group.scale.set(15, 15, 15);
        
        return group;
    }

    function createRPG() {
        const group = new THREE.Group();
        
        const tube = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 1, 8),
            new THREE.MeshPhongMaterial({ color: 0x555555 })
        );
        
        const grip = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.2, 0.05),
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        grip.position.set(0, -0.1, 0.1);
        
        const sight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, 0.05, 0.02),
            new THREE.MeshPhongMaterial({ color: 0x000000 })
        );
        sight.position.set(0, 0, 0.05);
        
        group.add(tube, grip, sight);
        group.scale.set(10, 10, 10);
        
        return group;
    }

    // --- WEAPON SYSTEM ---
    window.equip = function(weaponType) {
        gameState.currentWeapon = weaponType;
        
        // Remove current weapon
        if (currentWeaponObject && handBone) {
            handBone.remove(currentWeaponObject);
            currentWeaponObject = null;
        }
        
        // Update HUD
        document.getElementById('current-weapon').textContent = 
            `Weapon: ${gameState.weapons[weaponType].name}`;
        
        // Show ammo if not fists
        if (weaponType !== 'fist') {
            document.getElementById('ammo').style.display = 'block';
            updateAmmoDisplay();
            
            // Attach weapon model
            if (handBone && weaponModels[weaponType]) {
                currentWeaponObject = weaponModels[weaponType].clone();
                currentWeaponObject.rotation.set(Math.PI / 2, 0, 0);
                currentWeaponObject.position.set(0.1, 0, 0);
                handBone.add(currentWeaponObject);
            }
        } else {
            document.getElementById('ammo').style.display = 'none';
        }
        
        // Close weapon wheel
        document.getElementById('weapon-wheel').style.display = 'none';
    };

    function updateAmmoDisplay() {
        const weapon = gameState.weapons[gameState.currentWeapon];
        document.getElementById('ammo').textContent = 
            `${weapon.name}: ${weapon.ammo}${weapon.maxAmmo ? '/' + weapon.maxAmmo : ''}`;
    }

    function fireWeapon() {
        const weapon = gameState.weapons[gameState.currentWeapon];
        
        if (weapon.ammo === 0 || weapon.ammo === '‚àû') {
            // Play firing effect
            createMuzzleFlash();
            
            // Raycast for hit detection
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                const hit = intersects[0];
                createBulletImpact(hit.point, hit.face.normal);
                
                // Check if hit an object with health
                if (hit.object.userData.health) {
                    hit.object.userData.health -= weapon.damage;
                    if (hit.object.userData.health <= 0) {
                        scene.remove(hit.object);
                    }
                }
            }
            
            if (weapon.ammo !== '‚àû') {
                weapon.ammo--;
                updateAmmoDisplay();
                
                if (weapon.ammo === 0) {
                    setTimeout(() => {
                        weapon.ammo = weapon.maxAmmo;
                        updateAmmoDisplay();
                    }, 2000); // Reload delay
                }
            }
        }
    }

    function createMuzzleFlash() {
        const light = new THREE.PointLight(0xff6600, 2, 10);
        if (currentWeaponObject) {
            light.position.copy(currentWeaponObject.position);
            light.position.z += 1;
        } else {
            light.position.copy(camera.position);
            light.position.z -= 2;
        }
        scene.add(light);
        
        // Flash geometry
        const flashGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const flashMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00,
            transparent: true,
            opacity: 0.8
        });
        const flash = new THREE.Mesh(flashGeometry, flashMaterial);
        flash.position.copy(light.position);
        scene.add(flash);
        
        // Remove after short time
        setTimeout(() => {
            scene.remove(light);
            scene.remove(flash);
        }, 100);
    }

    function createBulletImpact(position, normal) {
        const geometry = new THREE.CircleGeometry(0.1, 8);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x888888,
            side: THREE.DoubleSide
        });
        const impact = new THREE.Mesh(geometry, material);
        impact.position.copy(position);
        impact.lookAt(position.clone().add(normal));
        scene.add(impact);
        
        setTimeout(() => {
            scene.remove(impact);
        }, 5000);
    }

    // --- CONTROLS ---
    const keys = {};
    let mouseSensitivity = 0.002;
    let pitch = 0;
    let yaw = 0;
    
    document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        switch(e.key) {
            case 'Tab':
                e.preventDefault();
                document.getElementById('weapon-wheel').style.display = 'flex';
                break;
            case 'f':
                toggleVehicle();
                break;
            case 'r':
                if (gameState.currentWeapon !== 'fist') {
                    const weapon = gameState.weapons[gameState.currentWeapon];
                    weapon.ammo = weapon.maxAmmo;
                    updateAmmoDisplay();
                }
                break;
            case ' ':
                if (player && !gameState.isDriving) {
                    player.position.y += 5;
                }
                break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });
    
    document.addEventListener('mousedown', (e) => {
        if (e.button === 0) { // Left click
            fireWeapon();
        }
    });
    
    document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === renderer.domElement) {
            yaw -= e.movementX * mouseSensitivity;
            pitch -= e.movementY * mouseSensitivity;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            
            if (player && !gameState.isDriving) {
                player.rotation.y = yaw;
            }
        }
    });
    
    renderer.domElement.addEventListener('click', () => {
        renderer.domElement.requestPointerLock();
    });

    function toggleVehicle() {
        if (!player || !truck) return;
        
        const distance = player.position.distanceTo(truck.position);
        
        if (!gameState.isDriving && distance < 20) {
            gameState.isDriving = true;
            player.visible = false;
            document.getElementById('vehicle-status').textContent = "Vehicle: Driving";
        } else if (gameState.isDriving) {
            gameState.isDriving = false;
            player.visible = true;
            player.position.copy(truck.position);
            player.position.x += 10;
            document.getElementById('vehicle-status').textContent = "Vehicle: Not in vehicle";
        }
    }

    // --- GAME LOOP ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        
        // Update animations
        if (playerMixer) {
            playerMixer.update(delta);
        }
        
        // Handle movement
        const moveSpeed = keys['shift'] ? 0.2 : 0.1;
        const target = gameState.isDriving ? truck : player;
        
        if (target) {
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            
            if (keys['w']) target.position.addScaledVector(forward, moveSpeed);
            if (keys['s']) target.position.addScaledVector(forward, -moveSpeed);
            if (keys['a']) target.position.addScaledVector(right, -moveSpeed);
            if (keys['d']) target.position.addScaledVector(right, moveSpeed);
            
            // Apply gravity
            if (!gameState.isDriving && player) {
                player.position.y = Math.max(0, player.position.y - 0.1);
            }
            
            // Update camera
            if (gameState.isDriving) {
                camera.position.copy(truck.position);
                camera.position.y += 10;
                camera.position.z += 15;
                camera.lookAt(truck.position);
            } else {
                const cameraOffset = new THREE.Vector3(0, 5, 10);
                cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                cameraOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch);
                camera.position.copy(target.position).add(cameraOffset);
                camera.lookAt(target.position);
            }
        }
        
        renderer.render(scene, camera);
    }

    // --- INITIALIZATION ---
    function init() {
        createWeaponModels();
        equip('fist');
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // Start the game
    init();
    </script>
</body>
</html>
