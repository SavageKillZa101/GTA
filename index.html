<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web GTA - Optimized Edition üî•</title>
    <style>
        * { margin: 0; padding: 0; }
        body { overflow: hidden; font-family: 'Courier New', monospace; background: #000; }
        canvas { display: block; }
        #hud {
            position: absolute; top: 20px; left: 20px; color: #0f0;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px;
            border: 2px solid #0f0; z-index: 100; font-size: 14px; min-width: 300px;
            backdrop-filter: blur(5px);
        }
        #hud h1 { color: #ffcc00; margin-bottom: 10px; text-shadow: 0 0 10px #ffcc00; }
        #hud div { margin: 5px 0; }
        #hud .key { display: inline-block; background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px; margin: 0 5px; border: 1px solid #0f0; }
        #weapon-wheel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px; height: 400px;
            background: radial-gradient(circle, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 70%, transparent 100%);
            border-radius: 50%; display: none; align-items: center; justify-content: center; z-index: 200;
            border: 3px solid #ffcc00; box-shadow: 0 0 50px rgba(255,204,0,0.5);
        }
        .weapon-slot { position: absolute; color: #fff; font-weight: bold; cursor: pointer; padding: 20px;
            transition: all 0.3s; background: rgba(255,255,255,0.1); border-radius: 50%; width: 80px; height: 80px;
            display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.3);
        }
        .weapon-slot:hover { background: #ffcc00; color: #000; transform: scale(1.2); border-color: #ffcc00; box-shadow: 0 0 20px #ffcc00; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; z-index: 50; pointer-events: none; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.8); }
        #crosshair::before { width: 20px; height: 2px; top: 9px; left: 0; }
        #crosshair::after { width: 2px; height: 20px; top: 0; left: 9px; }
        #ammo { position: absolute; bottom: 20px; right: 20px; color: #fff; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 4px #000; background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 10px; display: none; }
        #minimap { position: absolute; bottom: 20px; left: 20px; width: 200px; height: 200px; background: rgba(0,0,0,0.7);
            border-radius: 50%; overflow: hidden; border: 2px solid #0f0; z-index: 100; }
        #loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; color: #ffcc00; }
        .progress-bar { width: 300px; height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; margin-top: 20px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #ffcc00, #ff6600); width: 0%; transition: width 0.3s; }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>GTA WEB OPTIMIZED üî•</h1>
        <p>Loading... (Click canvas to lock mouse)</p>
        <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
    </div>
    <div id="crosshair"></div>
    <div id="ammo"></div>
    <div id="hud">
        <h1>GTA WEB v4.0</h1>
        <div>Health: <span id="health">100</span></div>
        <div>Money: $<span id="money">500</span></div>
        <div>Wanted: <span id="wanted">0</span> ‚≠ê</div>
        <div><span class="key">WASD</span> Move ‚Ä¢ <span class="key">Mouse</span> Look/Shoot</div>
        <div><span class="key">Shift</span> Sprint ‚Ä¢ <span class="key">Space</span> Jump ‚Ä¢ <span class="key">F</span> Enter/Exit Vehicle</div>
        <div><span class="key">Tab</span> Weapon Wheel ‚Ä¢ <span class="key">R</span> Reload ‚Ä¢ <span class="key">Click</span> Lock Mouse</div>
        <div id="current-weapon">Weapon: FISTS</div>
        <div id="vehicle-status">Status: On foot</div>
    </div>
    <div id="weapon-wheel">
        <div class="weapon-slot" style="top:10%;left:50%;transform:translateX(-50%)" onclick="equip('fist')">üëä</div>
        <div class="weapon-slot" style="top:50%;right:10%;transform:translateY(-50%)" onclick="equip('pistol')">üî´</div>
        <div class="weapon-slot" style="bottom:10%;left:50%;transform:translateX(-50%)" onclick="equip('shotgun')">üí•</div>
        <div class="weapon-slot" style="top:50%;left:10%;transform:translateY(-50%)" onclick="equip('m4')">üî´</div>
        <div class="weapon-slot" style="top:25%;left:25%" onclick="equip('katana')">üó°Ô∏è</div>
        <div class="weapon-slot" style="top:25%;right:25%" onclick="equip('rpg')">üöÄ</div>
    </div>
    <canvas id="minimap"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // Game state
    const gameState = {
        currentWeapon: 'fist',
        weapons: { fist: {name:'Fists',ammo:'‚àû',damage:15},
                   pistol: {name:'Pistol',ammo:15,maxAmmo:15,damage:25},
                   shotgun: {name:'Shotgun',ammo:8,maxAmmo:8,damage:60},
                   m4: {name:'M4',ammo:30,maxAmmo:30,damage:30},
                   katana: {name:'Katana',ammo:'‚àû',damage:50},
                   rpg: {name:'RPG',ammo:2,maxAmmo:2,damage:100} },
        isDriving: false,
        playerHealth: 100,
        playerMoney: 500,
        wantedLevel: 0,
        enemies: [], cops: [], projectiles: []
    };

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(100, 200, 100);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Audio
    const listener = new THREE.AudioListener();
    camera.add(listener);
    const audioLoader = new THREE.AudioLoader();
    const sounds = {};
    ['gunshot','explosion','engine'].forEach(name => {
        sounds[name] = new THREE.Audio(listener);
    });
    audioLoader.load('https://freesound.org/data/previews/276/276956_5123853-lq.mp3', buf => sounds.gunshot.setBuffer(buf));
    audioLoader.load('https://freesound.org/data/previews/387/387182_5123853-lq.mp3', buf => sounds.explosion.setBuffer(buf));
    audioLoader.load('https://freesound.org/data/previews/145/145817_2595768-lq.mp3', buf => { sounds.engine.setBuffer(buf); sounds.engine.setLoop(true); sounds.engine.setVolume(0.5); });

    // Loading
    const loader = new GLTFLoader();
    const minimapCtx = document.getElementById('minimap').getContext('2d');

    // Procedural city (always fast fallback)
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x333333}));
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);
    for(let i=0; i<50; i++){
        const h = Math.random()*80 + 20;
        const building = new THREE.Mesh(new THREE.BoxGeometry(20,h,20), new THREE.MeshStandardMaterial({color:Math.random()*0xffffff}));
        building.position.set(Math.random()*1000-500, h/2, Math.random()*1000-500);
        building.castShadow = true; building.receiveShadow = true;
        scene.add(building);
    }

    // Player & vehicle
    let player, playerMixer, handBone, vehicle, currentWeaponObject = null;

    // Simple vehicle
    function createVehicle(){
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(4,2,8), new THREE.MeshStandardMaterial({color:0xff0000}));
        group.add(body);
        const wheelGeo = new THREE.CylinderGeometry(1,1,0.5,16);
        const wheelMat = new THREE.MeshStandardMaterial({color:0x222222});
        [[-2,-1,-3],[2,-1,-3],[-2,-1,3],[2,-1,3]].forEach(p=>{
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI/2;
            w.position.set(...p);
            group.add(w);
        });
        group.position.set(30,1,30);
        scene.add(group);
        return group;
    }
    vehicle = createVehicle();

    // Load player (reliable three.js model)
    loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/Soldier.glb', gltf=>{
        player = gltf.scene;
        player.scale.set(2,2,2);
        player.position.y = 1;
        scene.add(player);
        playerMixer = new THREE.AnimationMixer(player);
        gltf.animations.forEach(c=>playerMixer.clipAction(c).play());
        handBone = player.getObjectByName('mixamorigRightHand');
        document.getElementById('loading-screen').style.display='none';
        document.getElementById('crosshair').style.display='block';
    }, undefined, ()=>{ // fallback box
        player = new THREE.Mesh(new THREE.BoxGeometry(2,4,2), new THREE.MeshStandardMaterial({color:0x00ff00}));
        player.position.y = 2;
        scene.add(player);
    });

    // Primitive weapons
    const weaponModels = {
        pistol: (()=>{ const g=new THREE.Group(); const b=new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.8),new THREE.MeshStandardMaterial({color:0x444444})); g.add(b); return g; })(),
        shotgun: (()=>{ const g=new THREE.Group(); const b=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,1.2,8),new THREE.MeshStandardMaterial({color:0x222222})); b.rotation.z=Math.PI/2; b.position.y=0.3; g.add(b); return g; })(),
        m4: (()=>{ const g=new THREE.Group(); const b=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,1.5),new THREE.MeshStandardMaterial({color:0x666666})); g.add(b); return g; })(),
        katana: (()=>{ const g=new THREE.Group(); const blade=new THREE.Mesh(new THREE.BoxGeometry(0.05,2,0.2),new THREE.MeshStandardMaterial({color:0xcccccc})); blade.position.y=0.8; g.add(blade); return g; })(),
        rpg: (()=>{ const g=new THREE.Group(); const tube=new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,2,8),new THREE.MeshStandardMaterial({color:0x555555})); g.add(tube); return g; })()
    };

    // Enemies & cops
    function spawnEnemy(pos){
        loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/RobotExpressive.glb', gltf=>{
            const e = gltf.scene.clone();
            e.position.copy(pos||new THREE.Vector3(Math.random()*200-100,1,Math.random()*200-100));
            e.userData = {health:80,type:'enemy'};
            e.traverse(n=>{if(n.isMesh)n.castShadow=true;});
            scene.add(e);
            gameState.enemies.push(e);
        });
    }
    for(let i=0;i<5;i++) spawnEnemy();
    function spawnCop(){
        loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/RobotExpressive.glb', gltf=>{
            const c = gltf.scene.clone();
            c.position.set(player.position.x+Math.random()*60-30,1,player.position.z+Math.random()*60-30);
            c.traverse(n=>{if(n.isMesh&&n.material)n.material=n.material.clone(); n.material.color.set(0x0000aa);});
            c.userData = {health:120,type:'cop'};
            scene.add(c);
            gameState.cops.push(c);
        });
    }

    // Weapon system
    window.equip = function(w){
        gameState.currentWeapon = w;
        if(currentWeaponObject && handBone) handBone.remove(currentWeaponObject);
        document.getElementById('current-weapon').textContent = `Weapon: ${gameState.weapons[w].name}`;
        if(w!=='fist'){
            document.getElementById('ammo').style.display='block';
            updateAmmo();
            if(handBone && weaponModels[w]){
                currentWeaponObject = weaponModels[w].clone();
                currentWeaponObject.scale.set(3,3,3);
                currentWeaponObject.rotation.set(0,Math.PI,0);
                currentWeaponObject.position.set(0.3,-0.3,-0.6);
                handBone.add(currentWeaponObject);
            }
        }else document.getElementById('ammo').style.display='none';
        document.getElementById('weapon-wheel').style.display='none';
    };
    function updateAmmo(){
        const w=gameState.weapons[gameState.currentWeapon];
        document.getElementById('ammo').textContent = `${w.name}: ${w.ammo}${w.maxAmmo?'/'+w.maxAmmo:''}`;
    }

    // Effects
    function createMuzzleFlash(){
        if(!sounds.gunshot.isPlaying) sounds.gunshot.play();
        const light = new THREE.PointLight(0xffaa00,3,30);
        light.position.copy(camera.position);
        light.position.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(3));
        scene.add(light);
        setTimeout(()=>scene.remove(light),100);
    }
    function createBulletImpact(point){
        const decal = new THREE.Mesh(new THREE.CircleGeometry(0.3,16), new THREE.MeshBasicMaterial({color:0x222222,side:THREE.DoubleSide}));
        decal.position.copy(point);
        decal.position.add(new THREE.Vector3(0,0.01,0));
        decal.lookAt(camera.position);
        scene.add(decal);
        setTimeout(()=>scene.remove(decal),8000);
    }
    function createExplosion(pos){
        if(sounds.explosion) sounds.explosion.play();
        const particles = new THREE.Points(
            new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(300).map(()=> (Math.random()-0.5)*20),3)),
            new THREE.PointsMaterial({color:0xff4400,size:1})
        );
        particles.position.copy(pos);
        scene.add(particles);
        setTimeout(()=>scene.remove(particles),1200);
    }

    // Shooting
    function fireWeapon(){
        const w = gameState.weapons[gameState.currentWeapon];
        if(w.ammo===0) return;
        createMuzzleFlash();
        if(w.ammo!=='‚àû') { w.ammo--; updateAmmo(); }
        if(w===gameState.weapons.rpg){
            const proj = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({color:0xff0000}));
            proj.position.copy(camera.position);
            proj.velocity = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(80);
            scene.add(proj);
            gameState.projectiles.push(proj);
        }else{
            const raycaster = new THREE.Raycaster(camera.position, camera.getWorldDirection(new THREE.Vector3()));
            const hits = raycaster.intersectObjects([...gameState.enemies,...gameState.cops], true);
            if(hits.length>0){
                const hit = hits[0].object.parent || hits[0].object;
                hit.userData.health -= w.damage;
                createBulletImpact(hits[0].point);
                if(hit.userData.health<=0){
                    scene.remove(hit);
                    gameState.enemies = gameState.enemies.filter(e=>e!==hit);
                    gameState.cops = gameState.cops.filter(c=>c!==hit);
                    gameState.playerMoney += 150;
                    document.getElementById('money').textContent = gameState.playerMoney;
                    gameState.wantedLevel = Math.min(5, gameState.wantedLevel+1);
                    document.getElementById('wanted').textContent = gameState.wantedLevel;
                    if(gameState.wantedLevel>=3) { spawnCop(); spawnCop(); }
                }
            }
        }
        if(w.ammo===0 && w.maxAmmo) setTimeout(()=>{w.ammo=w.maxAmmo; updateAmmo();},1800);
    }

    // Controls
    const keys = {};
    let yaw=0, pitch=0;
    const clock = new THREE.Clock();
    document.addEventListener('keydown', e=> { keys[e.key.toLowerCase()]=true; if(e.key==='Tab'){e.preventDefault(); document.getElementById('weapon-wheel').style.display='flex';} });
    document.addEventListener('keyup', e=> keys[e.key.toLowerCase()]=false);
    document.addEventListener('mousedown', e=>{ if(e.button===0 && document.pointerLockElement) fireWeapon(); });
    document.addEventListener('mousemove', e=>{
        if(document.pointerLockElement){
            yaw -= e.movementX*0.002;
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch - e.movementY*0.002));
        }
    });
    renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock());
    document.addEventListener('keydown', e=>{
        if(e.key==='f') toggleVehicle();
        if(e.key==='r' && gameState.currentWeapon!=='fist'){
            const w=gameState.weapons[gameState.currentWeapon];
            w.ammo = w.maxAmmo; updateAmmo();
        }
    });

    function toggleVehicle(){
        if(!player || !vehicle) return;
        if(player.position.distanceTo(vehicle.position)<12){
            gameState.isDriving = !gameState.isDriving;
            player.visible = !gameState.isDriving;
            if(gameState.isDriving){
                vehicle.rotation.y = yaw;
                sounds.engine.play();
                document.getElementById('vehicle-status').textContent = 'Status: Driving';
            }else{
                player.position.copy(vehicle.position);
                player.position.y += 3;
                sounds.engine.stop();
                document.getElementById('vehicle-status').textContent = 'Status: On foot';
            }
        }
    }

    function updateMinimap(){
        minimapCtx.clearRect(0,0,200,200);
        minimapCtx.fillStyle='#0f0';
        minimapCtx.fillRect(98,98,4,4); // player
        gameState.enemies.forEach(e=>{
            const dx = (e.position.x - (gameState.isDriving?vehicle.position.x:player.position.x))/8 + 100;
            const dz = (e.position.z - (gameState.isDriving?vehicle.position.z:player.position.z))/8 + 100;
            minimapCtx.fillStyle='#ff0000';
            minimapCtx.fillRect(dx,dz,4,4);
        });
        gameState.cops.forEach(c=>{
            const dx = (c.position.x - (gameState.isDriving?vehicle.position.x:player.position.x))/8 + 100;
            const dz = (c.position.z - (gameState.isDriving?vehicle.position.z:player.position.z))/8 + 100;
            minimapCtx.fillStyle='#0000ff';
            minimapCtx.fillRect(dx,dz,4,4);
        });
    }

    // Main loop
    function animate(){
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        if(playerMixer) playerMixer.update(delta);

        const target = gameState.isDriving ? vehicle : player;
        if(target) target.rotation.y = yaw;

        const speed = keys['shift'] ? 25 : 12;
        const dir = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        if(keys['w']) target.position.addScaledVector(dir, speed*delta);
        if(keys['s']) target.position.addScaledVector(dir, -speed*delta);
        if(keys['a']) target.position.addScaledVector(new THREE.Vector3(-1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw), speed*delta);
        if(keys['d']) target.position.addScaledVector(new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw), speed*delta);
        if(keys[' '] && !gameState.isDriving) target.position.y += 12*delta;

        if(!gameState.isDriving){
            target.position.y -= 20*delta;
            if(target.position.y<1) target.position.y=1;
        }

        // Projectiles
        gameState.projectiles = gameState.projectiles.filter(p=>{
            const oldPos = p.position.clone();
            p.position.addScaledVector(p.velocity, delta);
            const ray = new THREE.Raycaster(oldPos, p.velocity.clone().normalize(), 0, p.velocity.length()*delta);
            const hits = ray.intersectObjects(scene.children,true);
            if(hits.length>0 && hits[0].distance < p.velocity.length()*delta){
                createExplosion(hits[0].point);
                scene.remove(p);
                return false;
            }
            if(p.position.y<0){ createExplosion(p.position); scene.remove(p); return false; }
            return true;
        });

        // AI
        [...gameState.enemies, ...gameState.cops].forEach(n=>{
            const dirToPlayer = (gameState.isDriving?vehicle.position:player.position).clone().sub(n.position).normalize();
            const chaseSpeed = n.userData.type==='cop' ? 18 : 8;
            n.position.addScaledVector(dirToPlayer, chaseSpeed*delta);
            if(n.position.distanceTo(gameState.isDriving?vehicle.position:player.position)<4){
                gameState.playerHealth -= n.userData.type==='cop'?20:10;
                document.getElementById('health').textContent = Math.max(0,gameState.playerHealth);
            }
        });

        // Camera (smooth third-person)
        const camOffset = new THREE.Vector3(0,10,25).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        camera.position.copy(target.position).add(camOffset);
        camera.position.y += 5 + pitch*5;
        camera.lookAt(target.position.clone().add(new THREE.Vector3(0,5,0)));

        document.getElementById('health').textContent = gameState.playerHealth;
        if(gameState.playerHealth<=0) alert('Wasted! Reload page to try again.');

        updateMinimap();
        renderer.render(scene,camera);
    }

    equip('fist');
    animate();

    window.addEventListener('resize',()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    });
    </script>
</body>
</html>
